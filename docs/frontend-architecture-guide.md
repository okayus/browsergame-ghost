# React初学者向け フロントエンドアーキテクチャガイド

このドキュメントは、React初学者がこのゲームのフロントエンドコードを読んで学習するためのガイドです。
実装の詳細ではなく、**なぜそう設計されているか**に焦点を当てています。

---

## 目次

1. [フロントエンドの責務](#1-フロントエンドの責務)
2. [Reactが解決すること](#2-reactが解決すること)
3. [コンポーネント分割の理由](#3-コンポーネント分割の理由)
4. [Propsの設計理由](#4-propsの設計理由)
5. [バックエンドとのやりとり](#5-バックエンドとのやりとり)
6. [コードリーディングの順序](#6-コードリーディングの順序)

---

## 1. フロントエンドの責務

### フロントエンドとは何か

```
┌─────────────────────────────────────────────────────────────┐
│                      ブラウザ                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              フロントエンド (React)                   │   │
│  │  ・画面の描画                                        │   │
│  │  ・ユーザー入力の処理（キーボード、クリック）          │   │
│  │  ・ゲームの状態管理（現在の画面、パーティ、位置）      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↕ HTTP通信                         │
└─────────────────────────────────────────────────────────────┘
                           ↕
┌─────────────────────────────────────────────────────────────┐
│                    バックエンド (Hono)                       │
│  ・データの永続化（セーブデータ）                            │
│  ・認証の検証                                               │
└─────────────────────────────────────────────────────────────┘
```

### このアプリでのフロントエンドの役割

| 責務 | 説明 | 対応ファイル |
|------|------|-------------|
| **画面描画** | ゲーム画面をHTMLとして表示 | `components/` 配下 |
| **入力処理** | キーボード操作を受け取る | `GameContainer.tsx`, `App.tsx` |
| **状態管理** | 現在の画面、HP、位置などを保持 | `hooks/` 配下 |
| **API通信** | セーブデータの読み書き | `api/` 配下 |

---

## 2. Reactが解決すること

### 従来の問題：UIと状態の同期が難しい

従来のJavaScript（jQuery時代）では、状態が変わるたびに手動でDOMを更新する必要がありました。

```javascript
// 従来の方法（命令的UI）
let hp = 100;

function damage(amount) {
  hp -= amount;
  // 手動でUIを更新しなければならない
  document.getElementById('hp-bar').style.width = hp + '%';
  document.getElementById('hp-text').textContent = hp + '/100';
  if (hp <= 0) {
    document.getElementById('battle-result').style.display = 'block';
  }
}
```

問題点：
- 状態とUIの同期を自分で管理する必要がある
- 更新漏れによるバグが発生しやすい
- コードが複雑になる

### Reactの解決策：宣言的UI

Reactでは「状態がこうなら、UIはこう見える」と宣言するだけで、Reactが自動的にUIを更新してくれます。

```typescript
// Reactの方法（宣言的UI）
function HpBar({ currentHp, maxHp }: Props) {
  const percentage = (currentHp / maxHp) * 100;

  return (
    <div>
      <div style={{ width: `${percentage}%` }} />
      <span>{currentHp} / {maxHp}</span>
    </div>
  );
}
```

メリット：
- **状態を変えるだけでUIが自動更新される**
- UIの見た目がコードから予測しやすい
- 同期漏れによるバグが減る

### このアプリでの実例

```
packages/frontend/src/components/battle/GhostDisplay.tsx
```

HPが変わると、バーの幅と色が自動的に変わります：

```typescript
// currentHpが変わると、自動的にUIが更新される
const hpPercentage = (currentHp / maxHp) * 100;

// 50%以上なら緑、25%以上なら黄、それ以下は赤
const barColor = hpPercentage > 50 ? "green"
              : hpPercentage > 25 ? "yellow"
              : "red";
```

---

## 3. コンポーネント分割の理由

### ディレクトリ構成

```
src/components/
├── auth/          # 認証関連（ログイン、ローディング、エラー）
├── battle/        # バトル画面（コマンド、技選択、結果表示など）
├── game/          # 共通UI（コンテナ、メッセージ、セーブ状態）
├── map/           # マップ探索画面
├── menu/          # メニュー画面
└── party/         # パーティ管理画面
```

### なぜ機能別に分けるのか

**理由1: 関連するものをまとめる**

バトル画面に関するコンポーネントは `battle/` にまとめることで、「バトル画面を修正したい」と思ったときに探しやすくなります。

**理由2: 変更の影響範囲を限定する**

バトル画面のコードを変更しても、マップ画面には影響しません。

### コンポーネント階層図

```
App.tsx（全体の親）
│
├── 認証状態によって分岐
│   ├── WelcomeScreen（未ログイン）
│   ├── LoadingScreen（読み込み中）
│   └── ErrorScreen（エラー時）
│
└── GameContainer（ゲーム画面の枠）
    │
    └── 画面状態によって分岐
        ├── MapScreen（マップ探索）
        │   └── MapGrid
        │
        ├── BattleScreen（バトル）
        │   ├── GhostDisplay（敵）
        │   ├── GhostDisplay（味方）
        │   └── CommandPanel または SkillSelectPanel
        │
        ├── MenuScreen（メニュー）
        │
        └── PartyScreen（パーティ）
            ├── GhostSummaryCard（一覧）
            └── GhostDetailPanel（詳細）
```

### コンポーネント分割の原則

| 原則 | 説明 | 例 |
|------|------|-----|
| **単一責任** | 1つのコンポーネントは1つのことだけ担当 | `HpBar`はHPバーの表示だけ |
| **再利用性** | 同じUIは1つのコンポーネントにまとめる | `GhostDisplay`は敵にも味方にも使える |
| **適切な粒度** | 大きすぎず、小さすぎず | 画面全体は大きすぎ、`<div>`1つは小さすぎ |

---

## 4. Propsの設計理由

### Propsとは

親コンポーネントから子コンポーネントへデータを渡す仕組みです。

```
         ┌────────────────┐
         │     App.tsx    │
         │  party: [...] ─┼──────┐
         └────────────────┘      │ propsとして渡す
                                 ↓
         ┌────────────────┐
         │  PartyScreen   │
         │  party: [...]  │
         └────────────────┘
```

### なぜPropsを使うのか

**理由1: データの流れが明確になる**

```typescript
// どこからデータが来ているか一目でわかる
function PartyScreen({ party, onClose }: Props) {
  // partyは親から渡された
  // onCloseは親に通知するための関数
}
```

**理由2: コンポーネントが独立する**

`PartyScreen`は「パーティデータをどこから取得するか」を知らなくていい。
渡されたデータを表示するだけ。

### このアプリでのPropsパターン

#### パターン1: データを受け取る

```typescript
// GhostSummaryCard.tsx
interface Props {
  ghost: OwnedGhost;      // 表示するゴーストのデータ
  species: GhostSpecies;  // 種族情報
  isSelected: boolean;    // 選択されているか
}
```

#### パターン2: イベントを親に通知する

```typescript
// CommandPanel.tsx
interface Props {
  onSelectCommand: (command: BattleCommand) => void;  // コマンド選択時に親に通知
  canCapture: boolean;
}

// 使用側（親）
<CommandPanel
  onSelectCommand={handleBattleCommand}  // 親が処理を定義
  canCapture={true}
/>
```

#### パターン3: キーボード入力の伝達

```typescript
// 親（App.tsx）がキー入力を受け取り、子に伝える
<MenuScreen
  onKeyInput={keyInput}  // 親で検知したキー入力を子に渡す
  onSelectItem={handleMenuSelect}
  onClose={handleCloseMenu}
/>
```

### 型定義の重要性

```typescript
// 型を定義することで、どんなデータが必要かが明確になる
interface PartyScreenProps {
  party: OwnedGhost[];                    // ゴーストの配列
  speciesMap: Record<string, GhostSpecies>; // 種族データのマップ
  moves: Move[];                          // 技データ
  onClose: () => void;                    // 閉じる時のコールバック
}
```

TypeScriptの型があることで：
- 必要なデータが明確
- 間違ったデータを渡すとエラーになる
- エディタの補完が効く

---

## 5. バックエンドとのやりとり

### 通信が必要なタイミング

```
┌─────────────────────────────────────────────────────────────┐
│                     ゲームの流れ                             │
│                                                             │
│  ログイン ──→ セーブデータ読み込み ──→ ゲームプレイ ──→ 自動保存  │
│     ↓              ↓                                  ↓      │
│  認証API      GET /api/save                    POST /api/save │
└─────────────────────────────────────────────────────────────┘
```

### API通信の流れ

```
┌──────────────────┐     HTTP Request     ┌──────────────────┐
│                  │ ──────────────────→  │                  │
│   フロントエンド   │                      │   バックエンド    │
│    (React)       │ ←──────────────────  │    (Hono)        │
│                  │     HTTP Response    │                  │
└──────────────────┘                      └──────────────────┘
        │                                         │
        │ useSaveData.ts                          │ D1 Database
        │ - loadSaveData()                        │
        │ - saveToBacked()                        │
        └─────────────────────────────────────────┘
```

### 関連ファイル

| ファイル | 役割 |
|---------|------|
| `api/client.ts` | HTTPクライアントの設定 |
| `api/useSaveData.ts` | セーブデータの読み書きロジック |
| `hooks/useAuthState.ts` | 認証状態管理（API呼び出しを含む） |

### 認証の仕組み

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Clerk     │    │ フロントエンド │    │ バックエンド │
│ (認証サービス) │    │             │    │             │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       │ ←─ログイン画面─── │                  │
       │ ───トークン発行─→ │                  │
       │                  │ ─トークン付きリクエスト→ │
       │                  │                  │ トークン検証
       │                  │ ←──セーブデータ── │
       │                  │                  │
```

### オフライン対応

```typescript
// useSaveData.ts の仕組み

// 1. 通常時：サーバーに保存
saveToBackend(data) → 成功 → 完了

// 2. オフライン時：ローカルに保存
saveToBackend(data) → 失敗 → localStorage に保存

// 3. オンライン復帰時：ローカルのデータをサーバーに送信
window.addEventListener('online', syncPendingCache)
```

---

## 6. コードリーディングの順序

### ステップ1: エントリーポイントを理解する

```
src/main.tsx → src/App.tsx
```

- アプリがどこから始まるか
- 認証プロバイダー（ClerkProvider）の設定

### ステップ2: 画面遷移を追う

```
App.tsx の renderContent() を読む
```

- `authState.currentScreen` による分岐
- `gameState.currentScreen` による分岐

### ステップ3: 1つの画面を深掘りする

おすすめ: `PartyScreen`（比較的シンプル）

```
components/party/PartyScreen.tsx
├── GhostSummaryCard.tsx（一覧表示）
└── GhostDetailPanel.tsx（詳細表示）
```

理解すべきポイント：
- Propsでどんなデータを受け取っているか
- 状態（useState）で何を管理しているか
- どうやって子コンポーネントにデータを渡しているか

### ステップ4: カスタムフックを理解する

```
hooks/useGameState.ts（シンプル）
→ hooks/useMapState.ts（移動とエンカウント）
→ hooks/useBattleState.ts（複雑）
```

理解すべきポイント：
- どんな状態を管理しているか
- どんな関数（アクション）を提供しているか

### ステップ5: API通信を理解する

```
api/useSaveData.ts
```

理解すべきポイント：
- いつAPIを呼び出すか
- 成功/失敗時の処理

---

## 全体図：データの流れ

```
┌─────────────────────────────────────────────────────────────────────┐
│                            App.tsx                                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │
│  │useAuthState │ │useGameState │ │ useMapState │ │useBattleState│   │
│  │ ・認証状態   │ │ ・現在画面  │ │ ・位置      │ │ ・バトル状態 │   │
│  │ ・セーブ    │ │ ・パーティ  │ │ ・マップ    │ │ ・HP        │   │
│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘   │
│         │              │              │              │            │
│         └──────────────┴──────────────┴──────────────┘            │
│                               │                                    │
│                          props として                               │
│                               ↓                                    │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                     GameContainer                            │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐        │  │
│  │  │MapScreen │ │BattleScreen│ │MenuScreen│ │PartyScreen│       │  │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘        │  │
│  └─────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## まとめ

| 概念 | このアプリでの実践 |
|------|-------------------|
| **コンポーネント** | 機能別にディレクトリを分け、再利用可能な部品として設計 |
| **Props** | 親から子へデータを渡し、イベントは関数で親に通知 |
| **状態管理** | カスタムフック（useXxxState）でドメインごとに分離 |
| **API通信** | 専用のフック（useSaveData）でカプセル化 |

このドキュメントを参考に、実際のコードを読んでみてください。
「なぜこう書いてあるのか」を意識しながら読むことで、Reactの設計思想が身につきます。
